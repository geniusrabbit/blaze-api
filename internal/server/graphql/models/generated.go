// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/geniusrabbit/api-template-base/internal/server/graphql/types"
)

// Account is a company account that can be used to login to the system.
type Account struct {
	// The primary key of the Account
	ID int `json:"ID"`
	// Status of Account active
	Status      ApproveStatus `json:"status"`
	Title       string        `json:"title"`
	Description string        `json:"description"`
	// logoURI is an URL string that references a logo for the client.
	LogoURI string `json:"logoURI"`
	// policyURI is a URL string that points to a human-readable privacy policy document
	// that describes how the deployment organization collects, uses,
	// retains, and discloses personal data.
	PolicyURI string `json:"policyURI"`
	// termsOfServiceURI is a URL string that points to a human-readable terms of service
	// document for the client that describes a contractual relationship
	// between the end-user and the client that the end-user accepts when
	// authorizing the client.
	TermsOfServiceURI string `json:"termsOfServiceURI"`
	// clientURI is an URL string of a web page providing information about the client.
	// If present, the server SHOULD display this URL to the end-user in
	// a clickable fashion.
	ClientURI string `json:"clientURI"`
	// contacts is a array of strings representing ways to contact people responsible
	// for this client, typically email addresses.
	Contacts  []string  `json:"contacts"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type AccountEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *Account `json:"node"`
}

type AccountInput struct {
	ID                int           `json:"ID"`
	Status            ApproveStatus `json:"status"`
	Title             string        `json:"title"`
	Description       string        `json:"description"`
	LogoURI           string        `json:"logoURI"`
	PolicyURI         string        `json:"policyURI"`
	TermsOfServiceURI string        `json:"termsOfServiceURI"`
	ClientURI         string        `json:"clientURI"`
	Contacts          []string      `json:"contacts"`
}

type AccountListFilter struct {
	ID     []int           `json:"ID"`
	Title  []string        `json:"title"`
	Status []ApproveStatus `json:"status"`
}

type AccountListOrder struct {
	ID     *Ordering `json:"ID"`
	Title  *Ordering `json:"title"`
	Status *Ordering `json:"status"`
}

// AccountPayload wrapper to access of Account oprtation results
type AccountPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// Account ID operation result
	AccountID int `json:"accountID"`
	// Account object accessor
	Account *Account `json:"account"`
}

// AuthClient object represents an OAuth 2.0 client
type AuthClient struct {
	// ClientID is the client ID which represents unique connection indentificator
	ID        string `json:"ID"`
	AccountID int    `json:"accountID"`
	UserID    int    `json:"userID"`
	// Title of the AuthClient as himan readable name
	Title string `json:"title"`
	// Secret is the client's secret. The secret will be included in the create request as cleartext, and then
	// never again. The secret is stored using BCrypt so it is impossible to recover it. Tell your users
	// that they need to write the secret down as it will not be made available again.
	Secret string `json:"secret"`
	// RedirectURIs is an array of allowed redirect urls for the client, for example http://mydomain/oauth/callback .
	RedirectURIs []string `json:"redirectURIs"`
	// GrantTypes is an array of grant types the client is allowed to use.
	//
	// Pattern: client_credentials|authorization_code|implicit|refresh_token
	GrantTypes []string `json:"grantTypes"`
	// ResponseTypes is an array of the OAuth 2.0 response type strings that the client can
	// use at the authorization endpoint.
	//
	// Pattern: id_token|code|token
	ResponseTypes []string `json:"responseTypes"`
	// Scope is a string containing a space-separated list of scope values (as
	// described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client
	// can use when requesting access tokens.
	//
	// Pattern: ([a-zA-Z0-9\.\*]+\s?)+
	Scope string `json:"scope"`
	// Audience is a whitelist defining the audiences this client is allowed to request tokens for. An audience limits
	// the applicability of an OAuth 2.0 Access Token to, for example, certain API endpoints. The value is a list
	// of URLs. URLs MUST NOT contain whitespaces.
	Audience []string `json:"audience"`
	// SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a
	// list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
	SubjectType string `json:"subjectType"`
	// AllowedCORSOrigins are one or more URLs (scheme://host[:port]) which are allowed to make CORS requests
	// to the /oauth/token endpoint. If this array is empty, the sever's CORS origin configuration (`CORS_ALLOWED_ORIGINS`)
	// will be used instead. If this array is set, the allowed origins are appended to the server's CORS origin configuration.
	// Be aware that environment variable `CORS_ENABLED` MUST be set to `true` for this to work.
	AllowedCORSOrigins []string `json:"allowedCORSOrigins"`
	// Public flag tells that the client is public
	Public bool `json:"public"`
	// ExpiresAt contins the time of expiration of the client
	ExpiresAt time.Time  `json:"expiresAt"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt"`
}

type AuthClientEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *AuthClient `json:"node"`
}

type AuthClientInput struct {
	AccountID          *int      `json:"accountID"`
	UserID             *int      `json:"userID"`
	Title              string    `json:"title"`
	Secret             string    `json:"secret"`
	RedirectURIs       []string  `json:"redirectURIs"`
	GrantTypes         []string  `json:"grantTypes"`
	ResponseTypes      []string  `json:"responseTypes"`
	Scope              string    `json:"scope"`
	Audience           []string  `json:"audience"`
	SubjectType        string    `json:"subjectType"`
	AllowedCORSOrigins []string  `json:"allowedCORSOrigins"`
	Public             bool      `json:"public"`
	ExpiresAt          time.Time `json:"expiresAt"`
}

type AuthClientListFilter struct {
	ID        []string `json:"ID"`
	UserID    []int    `json:"userID"`
	AccountID []int    `json:"accountID"`
	Public    *bool    `json:"public"`
}

type AuthClientListOrder struct {
	ID         *Ordering `json:"ID"`
	UserID     *Ordering `json:"userID"`
	AccountID  *Ordering `json:"accountID"`
	Title      *Ordering `json:"title"`
	Public     *Ordering `json:"public"`
	LastUpdate *Ordering `json:"lastUpdate"`
}

// AuthClientPayload wrapper to access of AuthClient oprtation results
type AuthClientPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// AuthClient ID operation result
	AuthClientID string `json:"authClientID"`
	// AuthClient object accessor
	AuthClient *AuthClient `json:"authClient"`
}

// Information for paginating
type Page struct {
	// Start after the cursor ID
	After *string `json:"after"`
	// Page number to start at (0-based), defaults to 0 (0, 1, 2, etc.)
	StartPage *int `json:"startPage"`
	// Maximum number of items to return
	Size *int `json:"size"`
}

// Information for paginating
type PageInfo struct {
	// When paginating backwards, the cursor to continue.
	StartCursor string `json:"startCursor"`
	// When paginating forwards, the cursor to continue.
	EndCursor string `json:"endCursor"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// Total number of pages available
	Count int `json:"count"`
}

type Permission struct {
	Key    string   `json:"key"`
	Access []string `json:"access"`
}

type Profile struct {
	ID          int                 `json:"ID"`
	User        *User               `json:"user"`
	FirstName   string              `json:"firstName"`
	LastName    string              `json:"lastName"`
	CompanyName string              `json:"companyName"`
	About       string              `json:"about"`
	Email       string              `json:"email"`
	Messgangers []*ProfileMessanger `json:"messgangers"`
	CreatedAt   time.Time           `json:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt"`
}

type ProfileMessanger struct {
	Mtype   MessangerType `json:"mtype"`
	Address string        `json:"address"`
}

// A role is a collection of permissions. A role can be a child of another role.
type RBACRole struct {
	ID       int      `json:"ID"`
	ParentID *int     `json:"parentID"`
	Name     string   `json:"name"`
	Title    string   `json:"title"`
	Type     RoleType `json:"type"`
	//  Context is a JSON object that defines the context of the role.
	//  The context is used to determine whether the role is applicable to the object.
	//  The context is a JSON object with the following structure:
	//
	// {"cover": "system", "object": "model:Role"}
	//
	//  where:
	// "cover" - is a name of the cover area of the object type
	// "object" - is a name of the object type <module>:<object-name>
	Context                  *types.NullableJSON `json:"context"`
	ChildRolesAndPermissions []*RBACRole         `json:"childRolesAndPermissions"`
	CreatedAt                time.Time           `json:"createdAt"`
	UpdatedAt                time.Time           `json:"updatedAt"`
	DeletedAt                *time.Time          `json:"deletedAt"`
}

// RBACRoleEdge is a connection edge type for RBACRole.
type RBACRoleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *RBACRole `json:"node"`
}

type RBACRoleInput struct {
	ParentID *int                `json:"parentID"`
	Name     string              `json:"name"`
	Title    string              `json:"title"`
	Type     RoleType            `json:"type"`
	Context  *types.NullableJSON `json:"context"`
}

type RBACRoleListFilter struct {
	ID   []int      `json:"ID"`
	Name []string   `json:"name"`
	Type []RoleType `json:"type"`
}

type RBACRoleListOrder struct {
	ID    *Ordering `json:"ID"`
	Name  *Ordering `json:"name"`
	Title *Ordering `json:"title"`
	Type  *Ordering `json:"type"`
}

// RBACRolePayload wrapper to access of RBACRole oprtation results
type RBACRolePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// Role ID operation result
	RoleID int `json:"roleID"`
	// Role object accessor
	Role *RBACRole `json:"role"`
}

// SessionToken object represents an OAuth 2.0 / JWT session token
type SessionToken struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expiresAt"`
}

type User struct {
	// The primary key of the user
	ID int `json:"ID"`
	// Unical user name
	Username string `json:"username"`
	// Status of user active
	Status    ApproveStatus `json:"status"`
	CreatedAt time.Time     `json:"createdAt"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

type UserEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of the edge.
	Node *User `json:"node"`
}

type UserInput struct {
	Username *string `json:"username"`
}

type UserListFilter struct {
	ID     []int    `json:"ID"`
	Emails []string `json:"emails"`
	Roles  []int    `json:"roles"`
}

type UserListOrder struct {
	ID               *Ordering `json:"ID"`
	Email            *Ordering `json:"email"`
	Status           *Ordering `json:"status"`
	RegistrationDate *Ordering `json:"registrationDate"`
	Country          *Ordering `json:"country"`
	Manager          *Ordering `json:"manager"`
	LastUpdate       *Ordering `json:"lastUpdate"`
}

// UserPayload wrapper to access of user oprtation results
type UserPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// User ID operation result
	UserID int `json:"userID"`
	// User object accessor
	User *User `json:"user"`
}

// The list of statuses that shows is particular object active or paused
type ActiveStatus string

const (
	// All object by default have to be paused
	ActiveStatusPaused ActiveStatus = "PAUSED"
	// Status of the active object
	ActiveStatusActive ActiveStatus = "ACTIVE"
)

var AllActiveStatus = []ActiveStatus{
	ActiveStatusPaused,
	ActiveStatusActive,
}

func (e ActiveStatus) IsValid() bool {
	switch e {
	case ActiveStatusPaused, ActiveStatusActive:
		return true
	}
	return false
}

func (e ActiveStatus) String() string {
	return string(e)
}

func (e *ActiveStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActiveStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActiveStatus", str)
	}
	return nil
}

func (e ActiveStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The list of statuses that shows is object approved or not
type ApproveStatus string

const (
	// Pending status of the just inited objects
	ApproveStatusPending ApproveStatus = "PENDING"
	// Approved status of object could be obtained from the some authorized user who have permissions
	ApproveStatusApproved ApproveStatus = "APPROVED"
	// Rejected status of object could be obtained from the some authorized user who have permissions
	ApproveStatusRejected ApproveStatus = "REJECTED"
)

var AllApproveStatus = []ApproveStatus{
	ApproveStatusPending,
	ApproveStatusApproved,
	ApproveStatusRejected,
}

func (e ApproveStatus) IsValid() bool {
	switch e {
	case ApproveStatusPending, ApproveStatusApproved, ApproveStatusRejected:
		return true
	}
	return false
}

func (e ApproveStatus) String() string {
	return string(e)
}

func (e *ApproveStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApproveStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApproveStatus", str)
	}
	return nil
}

func (e ApproveStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The list of statuses that shows is particular object is available
type AvailableStatus string

const (
	// All object by default have to be undefined
	AvailableStatusUndefined AvailableStatus = "UNDEFINED"
	// Status of the available object
	AvailableStatusAvailable AvailableStatus = "AVAILABLE"
	// Status of the unavailable object
	AvailableStatusUnavailable AvailableStatus = "UNAVAILABLE"
)

var AllAvailableStatus = []AvailableStatus{
	AvailableStatusUndefined,
	AvailableStatusAvailable,
	AvailableStatusUnavailable,
}

func (e AvailableStatus) IsValid() bool {
	switch e {
	case AvailableStatusUndefined, AvailableStatusAvailable, AvailableStatusUnavailable:
		return true
	}
	return false
}

func (e AvailableStatus) String() string {
	return string(e)
}

func (e *AvailableStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AvailableStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AvailableStatus", str)
	}
	return nil
}

func (e AvailableStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessangerType string

const (
	MessangerTypeSkype    MessangerType = "SKYPE"
	MessangerTypeAim      MessangerType = "AIM"
	MessangerTypeIcq      MessangerType = "ICQ"
	MessangerTypeWhatsapp MessangerType = "WHATSAPP"
	MessangerTypeTelegram MessangerType = "TELEGRAM"
	MessangerTypeViber    MessangerType = "VIBER"
	MessangerTypePhone    MessangerType = "PHONE"
)

var AllMessangerType = []MessangerType{
	MessangerTypeSkype,
	MessangerTypeAim,
	MessangerTypeIcq,
	MessangerTypeWhatsapp,
	MessangerTypeTelegram,
	MessangerTypeViber,
	MessangerTypePhone,
}

func (e MessangerType) IsValid() bool {
	switch e {
	case MessangerTypeSkype, MessangerTypeAim, MessangerTypeIcq, MessangerTypeWhatsapp, MessangerTypeTelegram, MessangerTypeViber, MessangerTypePhone:
		return true
	}
	return false
}

func (e MessangerType) String() string {
	return string(e)
}

func (e *MessangerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessangerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessangerType", str)
	}
	return nil
}

func (e MessangerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Constants of the order of data
type Ordering string

const (
	// Ascending ordering of data
	OrderingAsc Ordering = "ASC"
	// Descending ordering of data
	OrderingDesc Ordering = "DESC"
)

var AllOrdering = []Ordering{
	OrderingAsc,
	OrderingDesc,
}

func (e Ordering) IsValid() bool {
	switch e {
	case OrderingAsc, OrderingDesc:
		return true
	}
	return false
}

func (e Ordering) String() string {
	return string(e)
}

func (e *Ordering) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ordering(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ordering", str)
	}
	return nil
}

func (e Ordering) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Role type defines whether the role is a role or a permission.
type RoleType string

const (
	RoleTypeRole       RoleType = "ROLE"
	RoleTypePermission RoleType = "PERMISSION"
)

var AllRoleType = []RoleType{
	RoleTypeRole,
	RoleTypePermission,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeRole, RoleTypePermission:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
